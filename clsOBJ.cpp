/*
* Program: clsOBJ
* Description:
*	Write  Wavefront Technologies's OBJ  image files
*
* Log:
*	20221115: created
*/

#include "clsOBJ.h"



// note in comments ensure that a # is at the beginning of each line.
// a # is assumed at the beginning of the comment
// *** todo: need to save normals ***
bool clsOBJ::SaveObj(const std::string FileName, const std::string Comments,
	const stVertex* VertexList, const int iVertexCount,
	const stFace3vertex* FaceList, const int iFaceCount,
	const stColour* stColourList, const int iColourCount) {

	/*


	char path_buffer[_MAX_PATH];
	char drive[_MAX_DRIVE];
	char dir[_MAX_DIR];
	char fname[_MAX_FNAME];
	char ext[_MAX_EXT];
	errno_t err;

	err = _splitpath_s(FileName.c_str(), drive, _MAX_DRIVE, dir, _MAX_DIR, fname, _MAX_FNAME, ext, _MAX_EXT);
	strcpy_s(ext, _MAX_EXT, ".obj");
	err = _makepath_s(path_buffer, _MAX_PATH, drive, dir, fname, ext);
	//char czLine[255];
	std::ofstream ObjFile; // (path_buffer);
	ObjFile.open(path_buffer, std::ios::out | std::ios::binary);
	if (!ObjFile.is_open()) {
		return false;
	};
	ObjFile << "# File Generated by HGOsource\n" << "# Original file name: " << fname << "\n";
	if (Comments.empty()) {
		ObjFile << "# Comments: \n#" << Comments << "\n";
	};

	ObjFile << "\n# Vertices\n";
	for (int i = 0; i < iVertexCount; ++i) {
		ObjFile << "v " << VertexList[i].x << " " << VertexList[i].y << " " << VertexList[i].z << "\n";
	};

	ObjFile << "\n# Faces\n";
	if ((iColourCount>0) && (iFaceCount> 0)) {
		ObjFile << "mtllib " << fname << ".mtl\n";
	};
	for (int i = 0; i < iFaceCount; ++i) {	// obj face index starts at 1, not zero
		if (ClrFaces()) {
			if (i == 0) {
				ObjFile << "usemtl Clr" << ColourIdx[i] << "\n";
			} else if (ColourIdx[i] != ColourIdx[i - 1]) {
				ObjFile << "usemtl Clr" << ColourIdx[i] << "\n";
			}
		};
		
		if (TextureCoords.size() == Points.size()) {
			// note that the v and vt index will be the same
			ObjFile << "f " << Faces[i].i[0] + 1 << "/" << Faces[i].i[0] + 1 << " " << Faces[i].i[1] + 1 << "/" << Faces[i].i[1] + 1 << " " << Faces[i].i[2] + 1 << "/" << Faces[i].i[2] + 1 << "\n";
		} else {
			ObjFile << "f " << Faces[i].i[0] + 1 << " " << Faces[i].i[1] + 1 << " " << Faces[i].i[2] + 1 << "\n";
		};
	};
	if ((Faces.size() == 0) && (Points.size() > 0)) {
		if (ClrPoints())
			ObjFile << "\n# Points\n";
		for (int i = 0; i < Points.size(); ++i) {
			if (ClrPoints()) {
				if (i == 0) {
					ObjFile << "usemtl Clr" << ColourIdx[i] << "\n";
				} else if (ColourIdx[i] != ColourIdx[i - 1]) {
					ObjFile << "usemtl Clr" << ColourIdx[i] << "\n";
				};
			};
			ObjFile << "p " << i + 1 << "\n";
		};
	};
	ObjFile.close();
	if (ClrFaces() || ClrPoints()) {
		strcpy_s(ext, _MAX_EXT, ".mtl");
		err = _makepath_s(path_buffer, _MAX_PATH, drive, dir, fname, ext);
		std::ofstream ObjFile(path_buffer);
		if (!ObjFile) {
			return false;
		};
		for (int i = 0; i < ColourTable.size(); ++i) {
			ObjFile << "newmtl Clr" << i << "\n" << "Kd "
				<< ((float)ColourTable[i].r) / 255.0f << " "
				<< ((float)ColourTable[i].g) / 255.0f << " "
				<< ((float)ColourTable[i].b) / 255.0f
				<< "\n";

		};
		ObjFile.close();
	};

	*/

	return true;
}


