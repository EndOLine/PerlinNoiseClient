/*
* Program: clsOBJ
* Description:
*	Write  Wavefront Technologies's OBJ  image files
*
* Log:
*	20221115: created
*/

#include "clsOBJ.h"



// note in comments ensure that a # is at the beginning of each line.
// a # is assumed at the beginning of the comment
// *** todo: need to save normals ***

bool  clsOBJ::SaveObj(const std::string FileName, const std::string Comments,
	const stVertex* VertexList, const int iVertexCount,
	const stFace3vertex* FaceList, const int iFaceCount,
	const clsRGBa* ColourList, const int iColourCount,
	const int* ColourIndexList, const int iColourIndexCount) {

	
	// disassemble file name to give it the proper extension
	char path_buffer[_MAX_PATH];
	char drive[_MAX_DRIVE];
	char dir[_MAX_DIR];
	char fname[_MAX_FNAME];
	char ext[_MAX_EXT];
	errno_t err;

	err = _splitpath_s(FileName.c_str(), drive, _MAX_DRIVE, dir, _MAX_DIR, fname, _MAX_FNAME, ext, _MAX_EXT);
	strcpy_s(ext, _MAX_EXT, ".obj");
	err = _makepath_s(path_buffer, _MAX_PATH, drive, dir, fname, ext);

	
	//char czLine[255];
	std::ofstream ObjFile; 
	ObjFile.open(path_buffer, std::ios::out | std::ios::binary);
	if (!ObjFile.is_open()) {
		return false;
	};
	ObjFile << "# File Generated by HGOsource\n" << "# Original file name: " << fname << "\n";
	if (!Comments.empty()) {
		ObjFile << "# Comments: \n#" << Comments << "\n";
	};

	ObjFile << "\n# Vertices\n";
	for (int i = 0; i < iVertexCount; ++i) {
		ObjFile << "v " << VertexList[i].x << " " << VertexList[i].y << " " << VertexList[i].z << "\n";
	};

	ObjFile << "\n# Faces\n";
	if ((iColourIndexCount > 0) && (iFaceCount > 0)) {
		ObjFile << "mtllib " << fname << ".mtl\n";
	};
	for (int i = 0; i < iFaceCount; ++i) {	
		if (iColourIndexCount >0) {
			if (i == 0) {
				ObjFile << "usemtl Clr" << ColourIndexList[i] << "\n";
			} else if (ColourIndexList[i] != ColourIndexList[i - 1]) {
				ObjFile << "usemtl Clr" << ColourIndexList[i] << "\n";
			}
		};
		// note face indicies in OBJ start at 1 not 0
		ObjFile << "f " << FaceList[i].i[0] + 1 << " " << FaceList[i].i[1] + 1 << " " << FaceList[i].i[2] + 1 << "\n";
		//if (TextureCoords.size() == Points.size()) {
		//	// note that the v and vt index will be the same
		//	ObjFile << "f " << Faces[i].i[0] + 1 << "/" << Faces[i].i[0] + 1 << " " << Faces[i].i[1] + 1 << "/" << Faces[i].i[1] + 1 << " " << Faces[i].i[2] + 1 << "/" << Faces[i].i[2] + 1 << "\n";
		//} else {
		//	ObjFile << "f " << Faces[i].i[0] + 1 << " " << Faces[i].i[1] + 1 << " " << Faces[i].i[2] + 1 << "\n";
		//};
	};
	if ((iFaceCount == 0) && (iVertexCount > 0)) {			
		ObjFile << "\n# Points\n";
		for (int i = 0; i < iVertexCount; ++i) {
			if (iColourIndexCount >0) {
				if (i == 0) {
					ObjFile << "usemtl Clr" << ColourIndexList[i] << "\n";
				} else if (ColourIndexList[i] != ColourIndexList[i - 1]) {
					ObjFile << "usemtl Clr" << ColourIndexList[i] << "\n";
				};
			};
			ObjFile << "p " << i + 1 << "\n";
		};
	};
	ObjFile.close();
	if (iColourCount > 0) {
		strcpy_s(ext, _MAX_EXT, ".mtl");
		err = _makepath_s(path_buffer, _MAX_PATH, drive, dir, fname, ext);
		std::ofstream ObjFile(path_buffer);
		if (!ObjFile) {
			return false;
		};
		for (int i = 0; i < iColourCount; ++i) {
			ObjFile << "newmtl Clr" << i << "\n" << "Kd "
				<< ((float)ColourList[i].r) / 255.0f << " "
				<< ((float)ColourList[i].g) / 255.0f << " "
				<< ((float)ColourList[i].b) / 255.0f
				<< "\n";

		};
		ObjFile.close();
	};

	

	return true;
}


